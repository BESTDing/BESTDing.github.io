[{"title":"CSS之column-count","date":"2017-03-19T15:40:50.000Z","path":"2017/03/19/CSS之column-count/","text":"column-count可以规定元素被分为多少列，配合使用的有下列CSS属性column-gap规定列之前间隔宽度column-rule规定列之间的宽度、样式和颜色。 用法 12345ul &#123; column-count: 2; column-gap: 1em; column-rule: 4px outset #ff0000;&#125; 样式如下","tags":[{"name":"column-count","slug":"column-count","permalink":"http://estding.com/tags/column-count/"}]},{"title":"ul标签的默认padding","date":"2017-03-19T15:22:26.000Z","path":"2017/03/19/ul标签的默认padding/","text":"今天用ul模仿写了一个下面这种效果，无奈自己写的时候发现ul不居中，于是就去看原网站的css代码发现有一下代码 123ul &#123; padding-left: 0px;&#125; 添加之后果然正常了，于是就搜了一下发现ul标签在FF中默认是有padding值的,而在IE中只有margin默认有值。默认值都是40px. so~~ul { padding-left: 0px; margin-left: 0px;} 可以解决一些布局上的问题。","tags":[{"name":"ul","slug":"ul","permalink":"http://estding.com/tags/ul/"}]},{"title":"CSS-margin","date":"2017-03-13T15:13:17.000Z","path":"2017/03/13/CSS-margin/","text":"margin标记可以带一个、二个、三个、四个参数，各有不同的含义。 margin: 20px;（上、下、左、右各20px。） margin: 20px 40px;（上、下20px；左、右40px。） margin: 20px 40px 60px;（上20px；左、右40px；下60px。） margin: 20px 40px 60px 80px;（上20px；右40px；下60px；左80px。） 在css中使用margin可以将margin-top，margin-right，margin-bottom，margin-left，缩写为一个标记，顺序为上右下左（顺时针）。","tags":[{"name":"margin","slug":"margin","permalink":"http://estding.com/tags/margin/"}]},{"title":"CSS-transform","date":"2017-03-08T14:01:14.000Z","path":"2017/03/08/CSS-transform/","text":"transform的属性包括 rotate()旋转 rotatex(), rotatey() skew() scale() 放大缩小 translate() rotate()旋转 1234.demo-transform &#123; transform: rotate(10deg); /*顺时针旋转十度*/ transform: rotate(-10deg); /*逆时针旋转十度*/&#125; skew()倾斜 123.demo-tranform &#123; transform: skew(20deg);&#125; scale()放大缩小 123.demo-transform &#123; transform: skew(1.5) /*放大1.5倍*/&#125; translate()变换，位移 1234.demo-transform &#123; transform: translate(120x, 20px) /*向上移动120px, 向右移动20px*/ transform: translate(-10px, -20px) /*向下移动10px, 向左移动移动20px*/&#125; 一个小栗子效果如下 代码如下 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"menu.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"logo\"&gt;&lt;/div&gt; &lt;div id=\"menu\"&gt; &lt;a href=\"#\" class=\"home-link\"&gt;主页&lt;/a&gt; &lt;a href=\"#\"&gt;目录&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132body &#123; font-family: Arial, Helvetica, sans-serif; color: #414142; background-color: #ededed;&#125;#menu &#123; position: absolute; top: -16px; left: -20px; width: 250px; transform: rotate(-35deg) translate(-92px, 22px); padding-top: 2em; transform-origin: 0 0; text-align: center; background-color: white;&#125;#menu .home-link &#123; margin-right: 1em;&#125;#menu a &#123; display: block; text-decoration: none; color: #8F8F8F; /*margin-right: 1em;*/&#125;#menu a:hover &#123; background-color: darkgray;&#125;","tags":[{"name":"CSS","slug":"CSS","permalink":"http://estding.com/tags/CSS/"},{"name":"transform","slug":"transform","permalink":"http://estding.com/tags/transform/"}]},{"title":"JavaScript操作符","date":"2017-02-05T12:36:33.000Z","path":"2017/02/05/JavaScript操作符/","text":"操作符操作符在应用于对象时,响应的操作符通常会调用对象的valueof()和(或)toString()方法，以便取得可以操作的值。1. 递增递减操作符 借鉴与C,递增和递减操作符在执行前置递增递减操作时，变量的值都是在语句被求值以前改变的，后置递增递减操作是在包含它们的语句被求值之后才执行的。 2. 一元加和减操作 在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换，转换规则遵守Number()的语法定义。 一元减操作符应用于非数值时，会先遵循一元加操作符的转换规则，最后再将得到的数值转换为负数。 3. 位操作符 按位非(NOt)，~执行结果是操作数的负值减1. 按位与(AND)， &amp; 按位或(OR), | 按位异或,(XOR) ^ 左移 &lt;&lt; 12var oldvalue = 2;var newValue = oldValue &lt;&lt; 5;左移5位 左移不会影响操作数的负号位，换句话说，如果将-2左移5位，结果将是-64，而非64. 有符号的右移， &gt;&gt; 这个操作符会将数值右移，但保留符号位(即正负号标记)JavaScript高级程序设计一书上描述，右移用符号位填充空位，如果是负数时不太懂 无符号右移， &gt;&gt;&gt;表示。这个操作符会将数值的所有32位都像右移动。对于整数结果与有符号右移相同，对于负数不同。 4. 布尔操作符 逻辑非 ! 逻辑与 &amp;&amp; 逻辑或 || 5. 乘性操作符 乘法 * 除法 / 求模 % 6. 加性操作符 加法 + 加法 - 7. 关系操作符 大于 &gt; 小于 &lt; 大于等于 &gt;= 小于等于 &lt;= 8. 相等操作符 相等 == 不相等 != 全等 === 两个操作数未经转换的情况下就返回true 不全等 !== 表示两个操作数，未经转换就不相等 9. 条件操作符boolean_expression ? true_value : false_value10. 赋值操作符复合赋值操作符11 逗号操作符 在一条语句执行多个操作，赋值总返回表达式最后一项。 instanceof操作符 判断某个对象是否是某个类型的实例， 1console.log(person instanceof Object) //true","tags":[]},{"title":"leetcode20","date":"2017-02-05T12:08:13.000Z","path":"2017/02/05/leetcode20/","text":"leetcode20 题目 Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 括号匹配的问题，利用栈的结构 12345678910111213141516171819202122232425262728'use strict'var isValid = function(s) &#123; var stack = [s[0]]; var left = ['(', '[', '&#123;']; var right = [')', ']', '&#125;']; if (s.length % 2 !== 0) return false; for (var i = 1; i &lt; s.length; i++) &#123; if (right.indexOf(s[i]) !== -1) &#123; if (stack[stack.length - 1] !== left[right.indexOf(s[i])]) &#123; return false; &#125; else &#123; stack.pop(); &#125; &#125; else &#123; stack.push(s[i]); &#125; &#125; if (stack.length === 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;;console.log(isValid(''));console.log(isValid('(&#123;[]&#125;)'));","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://estding.com/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://estding.com/tags/算法/"}]},{"title":"leetcode21","date":"2017-02-05T12:04:30.000Z","path":"2017/02/05/leetcode21/","text":"leetcode21 题目 Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 合并两个有序的链表，比较简单 123456789101112131415161718192021222324252627'use strict'function ListNode(val) &#123; this.val = val; this.next = null; &#125; var mergeTwoLists = function(l1, l2) &#123; var tmp = new ListNode(0), head = tmp; while(l1 &amp;&amp; l2) &#123; if (l1.val &gt; l2.val) &#123; tmp.next = l2; l2 = l2.next; &#125;else &#123; tmp.next = l1; l1 = l1.next; &#125; tmp = tmp.next; &#125; if (l1) &#123; tmp.next = l1; &#125; if (l2) &#123; tmp.next = l2; &#125; return head.next;&#125;;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://estding.com/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://estding.com/tags/算法/"}]},{"title":"JavaScript数据类型","date":"2017-01-20T15:39:00.000Z","path":"2017/01/20/JavaScript数据类型/","text":"5种基本类型 Undefined Null Boolean Number String 还有一种复杂的数据类型 object typeof 操作符 返回变量的数据类型 12typeof 'hello' //Stringtypeof 1 //Number 注意typeof是操作符不是函数，圆括号可以省略 1. Undefined 类型 在使用 var声明变量后但是并未对其初始化，此时变量的值就是 undefined,要理解Undefined和undefined,前者是类型，后者是值 123456var example;console.log(example); //Undefinedconsole.log(example == undefined); //truetypeof example; //undefined//注意undefined和未声明的变量是不一样但是 typeof对未定义的变量也是返回undefinedtypeof example2; //undefined 强烈建议显示初始化已经声明的变量 2. Null 类型 Null 类型也只有一个值 null, null表示一个空对象指针 1typeof null; //Object undefined 派生于null 3. Boolean 类型 Boolean类型有两个字面量值 true,false这两个字面量区分大小写敏感，也就是说True, False不是布尔值而是标识符，ECMAScript所有类型都有与这连个Boolean值等价的值，可以调用转换函数来转换 Boolean().具体转换规则如下。 String 非空字符串为true 空字符串为false Number 任何非零数字值都为true 0和NaN为false Object 任何对象都为true null为false Undefined undefined为false 4. Number类型 使用IEEE754表示整数和浮点数，十进制， 八进制 070第一位为0，注意八进制字面量在严格模式下无效，会导致JavaScript引擎抛出错误。注意在进行算术计算时，所有八进制和十六进制表示的数值最终都将被转换成十进制数值。 浮点数的精度在进行算术计算时其精度远远不如整数。例如，0.1+0.2的结果不是0.3而是0.30000000000000004,因此不要写下面这样的代码。 123if (a + b == 0.3) &#123; alert('You got 0.3.');&#125; 数值范围最小值 Number.MIN_VALUE, 最大值 Number.Max_VALUE,如果计算的结果超过最大和最小值得表示范围，这个数值会被自动转换为Infinity(正无穷),负数为-Infinity(负无穷)，Infinity不是能够参与计算的数值，确定一个值是不是无穷的用函数isFinite(). NaN，非数值是一个特殊的数值，表示一个本来要返回数值的操作数未返回数值的情况。特点：任何涉及NaN的操作都会返回NaN,另外NaN与任何值都不相等，包括NaN本身。alert(NaN == NaN) false.isNaN()函数在接受一个参数后，会尝试将这个值转换为数值，任何不能被转换为数值的值都会导致这个函数返回true,isNaN()同样适用于对象，接受对象参数后，会调用对象的 valueOf()方法，确定返回值是否可以转换为数值，如果不能，则基于这个返回值调用toString()方法，在测试返回值。注意这个过程也是ECMAScript 中内置函数和操作符的一般执行流程 数值转换，Number(), parseInt(), parseFloat().第一个函数适用于任何数据类型，后两个函数专门用于把字符串转换成数值。三个函数的转换规则不一样。 parseInt()的转换规则 忽略字符开头空格，知道第一个非空字符，如果第一个非空字符不是数字字符或负号，parseInt()就会返回NaN,也就是说，用paseInt()会继续解析第二个字符，知道解析玩后续所有字符或者遇到了一个非数字的字符。parseInt()也能识别十进制，八进制，和十六进制。另外ECMAScript已经不具备解析八进制值得能力，因此 ‘var num = parseInt(‘070’);’num为70.另外parseInt()接受第二参数用来指定按那个规则转换。最佳实践任何情况下都指定转换基数。 String 类型 任何字符串的长度，都可以通过其属性length获取，alert(text.length);. 字符串是不可变的 转换为字符串 toString()可以直接调用上述方法，null和undefined值没有toString()方法，另外在调用数值的toString()方法可以传入基数,例如 123var num = 10;console.log(num.toString()); //'10'console.log(num.toString(2)); //'1010' String() 如果参数有 toString()方法，则调用该方法，并返回响应的结果。 如果值为 null，则返回 ‘null’。 如果为‘undefined’, 则返回 ‘undefined’。 Object 类型 constructor: 保存构造函数 hasOwnProperty(propertyName): 用于检查给定的属性是否在当前对象的实例中，参数必须为字符串。 isPrototypeOf(Object): 用于检查传入对象是否是对象的原型。 propertyIsEnumerable(propertyName):用于检查给定的属相是否能够使用 for-in语句来枚举。参数必须为String. toLocalString(): 返回对象的字符串表示， toString()返回对象的字符串表示。 value偶发（）： 返回对象的字符串，数值或布尔值表示。通常于 toString()方法的返回值相同。 leetcode20 Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 12345678910111213141516171819202122232425'use strict'var isValid = function(s) &#123; var stack = [s[0]]; var left = ['(', '[', '&#123;']; var right = [')', ']', '&#125;']; if (s.length % 2 !== 0) return false; for (var i = 1; i &lt; s.length; i++) &#123; if (right.indexOf(s[i]) !== -1) &#123; if (stack[stack.length - 1] !== left[right.indexOf(s[i])]) &#123; return false; &#125; else &#123; stack.pop(); &#125; &#125; else &#123; stack.push(s[i]); &#125; &#125; if (stack.length === 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;;","tags":[]},{"title":"leetcode19","date":"2017-01-15T09:14:20.000Z","path":"2017/01/15/leetcode19/","text":"leetcode19 题目 Remove Nth Node From End of List Add to List QuestionEditorial Solution My SubmissionsTotal Accepted: 153939Total Submissions: 478913Difficulty: EasyContributors: AdminGiven a linked list, remove the nth node from the end of list and return its head. For example, Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Try to do this in one pass. Subscribe to see which companies asked this question 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546'use strict'function ListNode(val) &#123; this.val = val; this.next = null; &#125;var removeNthFromEnd = function(head, n) &#123; var b = null; var m = head; var f = head; for (var i = 1; i &lt; n; i++) &#123; f = f.next; &#125; while(f.next != null) &#123; b = m; m = m.next; f = f.next; &#125; if (m === head) &#123; head = head.next; &#125; else if(m === f)&#123; //f = null; /*这个地方是个坑，本来以为只要上面一行代码就可以解决,这个涉及到垃圾回收机制，只把f设为null,还是有其他变量引用这个节点，所以并没有达到删除这个节点的目的。 */ b.next = null; m = null; f = null; &#125; else &#123; b.next = m.next; m = null; &#125; return head;&#125;;var head = new ListNode(1);var second = new ListNode(2);var third = new ListNode(3);var forth = new ListNode(4);var fifth = new ListNode(5);head.next = second;second.next = third;third.next = forth;forth.next = fifth;var resultNode = removeNthFromEnd(head, 2);console.log(resultNode);","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://estding.com/tags/leetcode/"},{"name":"算法","slug":"算法","permalink":"http://estding.com/tags/算法/"}]},{"title":"leetcode17","date":"2017-01-08T13:22:01.000Z","path":"2017/01/08/leetcode17/","text":"这是leetcode17的JS实现，运用递归的思想，刚学JS代码比较挫 题目 Given a digit string, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. 12Input:Digit string &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note:Although the above answer is in lexicographical order, your answer could be in any order you want. Subscribe to see which companies asked this question Show TagsShow Similar Problems 代码 1234567891011121314151617181920212223242526272829303132333435'use strict'var letterCombinations = function(digits) &#123; var mapArray = [ , , ['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i'], ['j', 'k', 'l'], ['m', 'n', 'o'], ['p', 'q', 'r', 's'], ['t', 'u', 'v'], ['w', 'x', 'y', 'z'] ]; var resultArray = []; var temp = []; if (digits.length &lt; 1) &#123; return resultArray; &#125; myFunc(digits, temp, resultArray, mapArray); return resultArray;&#125;;function myFunc(digits, temp, resultArray, mapArray) &#123; var currentLen = temp.length; if (currentLen == digits.length) &#123; var tempStr = ''; for (var k=0; k &lt; temp.length; k++) &#123; tempStr += temp[k]; &#125; resultArray.push(tempStr); &#125; else &#123; for (var i=0; i&lt; mapArray[Number(digits[currentLen])].length; i++) &#123; temp.push(mapArray[Number(digits[currentLen])][i]); myFunc(digits, temp, resultArray, mapArray); temp.pop(); //退回到上一层 &#125; &#125;&#125;var resultArray = letterCombinations('2');console.log(resultArray);","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://estding.com/tags/leetcode/"}]},{"title":"Python正则表达式","date":"2016-12-04T13:08:46.000Z","path":"2016/12/04/Python正则表达式/","text":"正则基础 \\d 匹配一个数字 \\w 匹配一个字母或数字 . 匹配任意一个字符 * 表示任意个字符包括0个 + 表示至少一个字符 ? 表示0个或1个字符 {n} 表示n个字符 {n,m} 表示n-m个字符 \\s 匹配一个空格 [] 中括号可以用来指定一个范围 A|B 匹配A或B ^ ^\\d 以数字开头 \\d$ 以数字结尾 example12345\\d&#123;3&#125; 表示3个数字\\d&#123;3,8&#125; 表示3-8个数字\\s+ 表示至少一个空格[0-9] 匹配0-9之间的一个数字[0-9]+ 至少有一个0-9之间的数字 Python re模块 re.match(re, str) match()方法接收一个正则表达式和一个字符串，如果有匹配返回一个 match对象， 否则返回None re.split(re, str) 切分字符串 用正则表达式切分字符串 1234re.split(r'\\s+', 'a b c')['a', 'b', 'c']re.split(r'[\\s\\,]+', 'a,b, c d')['a', 'b', 'c', 'd'] 定义分组 ‘m.group()’ m是一个 match对象 12345678910^(\\d&#123;3&#125;)-(\\d&#123;3-8&#125;)$上面的代码用小括号定义两个分组m = re.match(r'^(\\d&#123;3&#125;)-(\\d&#123;3-8&#125;)$', '010-12345')m.group(1)'010'm.group(2)'12345'group(0)'010-12345' 贪婪匹配 最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0： 123456re.match(r'^(\\d+)(0*)$', '102300').groups()#('102300', '')\\d+采用贪婪匹配，直接匹配了所有的数字，结果0*只能匹配空字符串了。加？号让\\d+采非贪婪匹配re.match(r'^(\\d+?)(0*)$', '102300').groups()#('1023', '00') 编译正则表达式 当我们在Python中使用正则表达式时，re模块内部会干两件事情： 编译正则表达式，如果正则表达式的字符串本身不合法，会报错； 用编译后的正则表达式去匹配字符串。 如果一个正则表达式使用非常频繁，可以预编译正则表达式，提高效率 1234import rere_c = re.compile(r'^(\\d&#123;3&#125;)-(\\d&#123;3,8&#125;)$')re_c.match('010-12345').groups()#('010', '12345') 练习 匹配邮箱 123mail_re = re.compile(&apos;[0-9a-zA-z]*\\@(gmail|microsoft)&apos;)re.match(&apos;someone@gmail.com&apos;)","tags":[{"name":"Python","slug":"Python","permalink":"http://estding.com/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://estding.com/tags/正则表达式/"}]},{"title":"git学习笔记(-)","date":"2016-11-20T16:04:06.000Z","path":"2016/11/21/git学习笔记1/","text":"git修改远程仓库地址 3种方法 12345git remote origin set-url url#先移除后添加git remote rm origingit remote add origin url#直接修改config 文件 git设置(git config)git-config设置主要可以存放在一下三个不同的地方 /etc/gitconfig文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。 ~/.gitconfig文件：~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。 当前项目目录中的git配置文件 .git/config这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings\\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 配置用户名和邮箱123\u0010# 配置用户名和邮箱 git config --global user.name \"EstDing\" git config --global user.email estding0@gmail.com 查看配置信息1git config --list git clone指定文件名称12#这个命令会将远程仓库的文件克隆岛myfile文件夹内git clong url myfile git 文件状态 未跟踪(新增的文件或者从始至终都没有加入版本跟踪的文件) 已跟踪(使用git add命令添加过的文件) 已修改() 已修改保存到暂存区(使用git add命令后的文件会被放到暂存区) 已提交(git commit提交之后就会产生一个版本记录) 查看文件状态1git status .gitignore 设置对那些文件不进行版本跟踪.gitignore文件的规范： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。","tags":[{"name":"git","slug":"git","permalink":"http://estding.com/tags/git/"}]},{"title":"将博客从github迁移到coding.net","date":"2016-11-20T01:40:32.000Z","path":"2016/11/20/将博客从github迁移到coding-net/","text":"最近github不知道抽什么风我部署在github上的博客一直访问不了，奈何囊中羞涩供不起vps于是就想把blog迁移到国内的coding.net上，迁移大致有以下几个步骤 注册coding.net，并新建一个和你用户名一样的项目。 修改配置文件_config.yml 在source目录下创建 Staticfile文件 域名绑定 部署 注册coding.net，并新建一个和你用户名一样的项目。这个很简单不在赘述 修改配置文件_config.yml修改_config.yml文件添加coding.net部署仓库 1234567deploy: - type: git repo: https://github.com/BESTDing/BESTDing.github.io.git branch: master - type: git repo: git@git.coding.net:EstDing/EstDing.git,coding-pages branch: coding-pages 注意coding.net的pages服务是coding-pages分支 3 在source目录下创建 Staticfile文件 切换到source目录执行 1touch Staticfile 4 域名绑定 我的域名是在腾讯云购买的，所以直接用的腾讯云解析按照下面图片的格式配置域名解析，如果你同时部署在了github上可以设置国外线路只想github 5 部署 执行下面命令 123hexo cleanhexo ghexo d 6 参考文章 更详细教程","tags":[{"name":"blog","slug":"blog","permalink":"http://estding.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://estding.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://estding.com/tags/github/"},{"name":"coding.net","slug":"coding-net","permalink":"http://estding.com/tags/coding-net/"}]},{"title":"技嘉z170x-ud3 i7-6700k黑苹果教程","date":"2016-11-19T15:18:08.000Z","path":"2016/11/19/技嘉z170x-ud3 i7-6700K黑苹果教程/","text":"感谢远景坛友翻译和搬运: 原贴地址 电脑配置 BIOS F5b 下载 CPU i7-6700k 主板 技嘉 z170x-ud3 ultra 内存 金士顿骇客神条 8GB DDR4 2400 MHz 显卡 技嘉GTX770 4G (免驱具体怎么设置后面会说到) 显示器 戴尔 u2414h 声卡 Realtek ALC1150 以太网卡 Intel I219V2 无线网卡 AR9380 已经驱动的设备 SATA USB 2.0 和 USB 3.0 声卡 CPU 变频(未使用DSDT) 显卡 变频正常 睡眠正常 网卡內建 固态硬盘开启TRIM HD530 免驱 未驱动设备 USB 3.1 TypeA可以供电不可以挂载设备 USB 3.1 TypeC可以供电不可以挂载设备，我的安卓手机插上只能充电不能挂载。 准备 下载 Sierra安装镜像这个直接去AppStore下载就好了 需要下载的文件 Clover Files.zip HFSPlus.efi Clover Installer audio cloverAlc-120.command.zip audio cloverHDMI-110.command ssdtPRGen (CPU PWM) (Left click and “Download Linked File”) freqVectorsEdit.sh USB-SSDT.zip Nvidia drivers for Sierra 打包下载360云盘提取码:（提取码：2a19） BIOS 设置(很重要)一下设置不同BIOS版本可能会不同，但是你只要BIOS上有的就按照下面的设置。有坑的地方我会在下面说明的。 In BIOS Features。 Fast Boot: Disabled Windows 8/10 Fatures: Windows 8/10 CSM Support: Disabled Network Stack: Disabled In Peripherals: ntel Platform Trust Technology: Disabled Initial Display Output: PCIe 1 Slot (Or whatever slot your GFX is in) Legacy USB Support: Enabled XHCI Hand-off: Enabled Port 60/64 Emulation: Disabled In Super IO Configuration: Serial Port 1: Disabled In Chipset: VT-d: Disabled Internal Graphics: Disabled(如果你用核显的话这一项设置成Auto设置成Disabled就把核显关了，另外如果你有独显这个一定要设置成Auto或者Disabled不然独显无法驱动) Audio Controller: Enabled PCH LAN Controller: Enabled IOAPIC 24-119 Entries: Enabled 设置USB接口这个直接去原贴看一下吧！！ 从10.11升级到10.12(亲测)升级前的一些准备 下载Clover（上面打包下载） 移除一下文件从EFI文件夹中： /EFI/CLOVER/kexts/Other/AppleALC.kext (Currently causes unbootable system on Sierra导致无法启动) 用上面下载的 Clover Files-10.12.zip中的一下文件替换现有EFI中的文件： SSDT-HDEF-HDAS-1.aml (/EFI/CLOVER/ACPI/patched) IntelMausiEthernet.kext (/EFI/CLOVER/kext/Other) Set CsrActiveConfig to 0x67 (Disable SIP关闭SIP). 开始更新 运行 macOS Sierra.app选择要安装磁盘 重启后选择从安装盘启动别忘了 加上 nv_disable=1（没有n卡的不用加） 安装完成后再次重启也要加上 nv_disable=1参数 不是免驱的n卡 安装webdrivers run AGDPFix.app(免驱卡解决显示器无信号) 重启 执行 audio_cloverALC-120.command驱动声卡 If using macPro6,1: Unpack freqVectorsEdit.sh-master.zip, run freqVectorsEdit.sh. Choose the option called: “Mac-65CE76090165799A.plist (iMac17,1)”(这一步我没有执行)9 重启 enjoy 免驱显卡设置所有Clover关于n卡参数都不要勾选 nv_disables,nvda_drv, inject_nvidia，最后bios里一定要禁用核显。 原版安装 10.12 制作安装盘 1sudo \"/Applications/Install macOS Sierra.app/Contents/Resources/createinstallmedia\" --volume /Volumes/`Untitled(替换为你分区的名称)`--applicationpath \"/Applications/Install macOS Sierra.app\" --nointeraction 制作Clover引导 运行Clover安装文件选择自定义安装 选择一下安装选项 Install for UEFI booting onlyDrivers64UEFI Driver64EFI OsxAptioFix2Drv-64 EmuVariableUefi-64 复制旗下文件到EFI ACPI/patched/SSDT-5.aml ACPI/patched/USB-SSDT.aml config.plist kexts/Other/FakeSMC.kext kexts/Other/IntelMausiEthernet.kext kexts/Other/CodecCommander.kext drivers64UEFI/HFSPlus.efi ACPI/patched/XOSI-WIN10.aml ACPI/patched/SSDT-HDEF-HDAS-1.aml 删除一下文件 kexts/10.* drivers64UEFI/VBoxHfs-64.efi 安装和升级步骤一样 其他说明以上步骤不一定都要全部执行我就有一部分没执行，如果配置和我的一样可以直接那我的EFI试一下一般都会成功 最后祝所有正在折腾的朋友，早日吃上黑果","tags":[{"name":"黑苹果","slug":"黑苹果","permalink":"http://estding.com/tags/黑苹果/"}]},{"title":"Swift随机颜色","date":"2016-10-23T03:23:21.000Z","path":"2016/10/23/Swift随机颜色/","text":"我们利用arc4randomuniform()产生三个随机值，再用UIColor构造方法返回一个随机颜色实例，你可以将下面一段代码拖入代码段以便随时服用 123456func randomColor() -&gt; UIColor &#123; let red = (CGFloat(arc4random_uniform(255)) / 255.0) let green = (CGFloat(arc4random_uniform(255)) / 255.0) let blue = (CGFloat(arc4random_uniform(255)) / 255.0) return UIColor(red: red, green: green, blue: blue, alpha: 1.0) &#125;","tags":[{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"UIColor","slug":"UIColor","permalink":"http://estding.com/tags/UIColor/"}]},{"title":"Swift中的Pragma mark","date":"2016-10-17T14:04:55.000Z","path":"2016/10/17/Swift中的pragmamark/","text":"之前写OC时都是用#pragma mark-生成分割线，用#pragma mark 生成函数说明 在Swift中发现这个语法不管用了，Google了一下发现有了新的用法， //// MARK: - 生成分隔线 // MARK: 说明 冒号不要丢","tags":[{"name":"iOS","slug":"iOS","permalink":"http://estding.com/tags/iOS/"},{"name":"SWift","slug":"SWift","permalink":"http://estding.com/tags/SWift/"},{"name":"Pragma mark","slug":"Pragma-mark","permalink":"http://estding.com/tags/Pragma-mark/"}]},{"title":"iOS学习-NSLayoutConstraint-Swift3","date":"2016-10-17T13:25:59.000Z","path":"2016/10/17/iOS学习-NSLayoutConstraint-Swift3/","text":"约束是定义两个组件之间的布局关系，必须满足基本的系统布局约束，每个约束都有以下形式 1item1.attribute1 = multiplier × item2.attribute2 + constant 意思就是item1的布局属性等于item2的布局属性*multiplier再加上一个常量 In this equation, attribute1 and attribute2 are the variables that Auto Layout can adjust when solving these constraints. The other values are defined when you create the constraint. For example, If you’re defining the relative position of two buttons, you might say “the leading edge of the second button should be 8 points after the trailing edge of the first button.” The linear equation for this relationship is shown below: 在这个方程中，attribute1和attribute2是Auto Layout在求解这些约束时可以调整的变量。 其他值是在创建约束时定义的。 例如，如果要定义两个按钮的相对位置，可以说“第二个按钮的前缘应该在第一个按钮的后缘之后8个点”。这种关系的线性方程如下所示： 1button2.leading = 1.0 * button1.trailing + 8.0 *Auto Layout then modifies the values of the specified leading and trailing edges until both sides of the equation are equal. Note that Auto Layout does not simply assign the value of the right side of this equation to the left side. Instead, the system can modify either attribute or both attributes as needed to solve for this constraint. The fact that constraints are equations (and not assignment operators) means that you can switch the order of the items in the equation as needed to more clearly express the desired relationship. However, if you switch the order, you must also invert the multiplier and constant. For example, the following two equations produce identical constraints:* 然后自动布局修改指定的前沿和后沿的值，直到等式的两边相等。 请注意，自动布局不会简单地将该公式右侧的值分配给左侧。 相反，系统可以根据需要修改任一属性或两个属性以解决该约束。约束是方程（而不是赋值运算符）意味着您可以根据需要切换方程中项的顺序，以更清楚地表达所需的关系。 但是，如果切换顺序，还必须反转乘数和常数。 例如，以下两个方程产生相同的约束： 123// These equations produce identical constraintsbutton2.leading = 1.0 × button1.trailing + 8.0button1.trailing = 1.0 × button2.leading - 8.0 A valid layout is defined as a set constraints with one and only one possible solution. Valid layouts are also referred to as a nonambiguous, nonconflicting layouts. Constraints with more than one solution are ambiguous. Constraints with no valid solutions are conflicting. For more information on resolving ambiguous and conflicting constraints, see Types of Errors in Auto Layout Guide. Additionally, constraints are not limited to equality relationships. They can also use greater than or equal to (&gt;=) or less than or equal to (&lt;=) to describe the relationship between the two attributes. Constraints also have priorities between 1 and 1,000. Constraints with a priority of 1,000 are required. All priorities less than 1,000 are optional. By default, all constraints are required (priority = 1,000). After solving for the required constraints, Auto Layout tries to solve all the optional constraints in priority order from highest to lowest. If it cannot solve for an optional constraint, it tries to come as close as possible to the desired result, and then moves on to the next constraint. This combination of inequalities, equalities, and priorities gives you a great amount of flexibility and power. By combining multiple constraints, you can define layouts that dynamically adapt as the size and location of the elements in your user interface change. For some example layouts, see Stack Views in Auto Layout Guide. 有效布局被定义为具有一个且仅一个可能解决方案的集合约束。有效的布局也称为无歧义，不冲突的布局。使用多个解决方案的约束是模糊的。没有有效解决方案的约束是冲突的。有关解决模糊和冲突约束的更多信息，请参阅自动布局指南中的错误类型。 另外，约束不限于等式关系。它们还可以使用大于或等于（&gt; =）或小于或等于（&lt;=）来描述这两个属性之间的关系。约束的优先级也在1到1,000之间。需要优先级为1,000的约束。所有优先级小于1,000是可选的。默认情况下，所有约束都是必需的（priority = 1,000）。 解决所需的约束后，Auto Layout会尝试按优先级顺序从最高到最低解决所有可选约束。如果它不能解决可选的约束，它会尽可能接近所需的结果，然后移动到下一个约束。 这种不等式，平等性和优先级的组合为您提供了大量的灵活性和强大的功能。通过组合多个约束，您可以定义随用户界面中元素的大小和位置更改而动态适应的布局。有关布局的一些示例，请参阅自动布局指南中的堆栈视图。 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788open class NSLayoutConstraint : NSObject &#123; /* Create an array of constraints using an ASCII art-like visual format string. */ open class func constraints(withVisualFormat format: String, options opts: NSLayoutFormatOptions = [], metrics: [String : Any]?, views: [String : Any]) -&gt; [NSLayoutConstraint] /* This macro is a helper for making view dictionaries for +constraintsWithVisualFormat:options:metrics:views:. NSDictionaryOfVariableBindings(v1, v2, v3) is equivalent to [NSDictionary dictionaryWithObjectsAndKeys:v1, @\"v1\", v2, @\"v2\", v3, @\"v3\", nil]; */ // not for direct use /* Create constraints explicitly. Constraints are of the form \"view1.attr1 = view2.attr2 * multiplier + constant\" If your equation does not have a second view and attribute, use nil and NSLayoutAttributeNotAnAttribute. */ public convenience init(item view1: Any, attribute attr1: NSLayoutAttribute, relatedBy relation: NSLayoutRelation, toItem view2: Any?, attribute attr2: NSLayoutAttribute, multiplier: CGFloat, constant c: CGFloat) /* If a constraint's priority level is less than UILayoutPriorityRequired, then it is optional. Higher priority constraints are met before lower priority constraints. Constraint satisfaction is not all or nothing. If a constraint 'a == b' is optional, that means we will attempt to minimize 'abs(a-b)'. This property may only be modified as part of initial set up or when optional. After a constraint has been added to a view, an exception will be thrown if the priority is changed from/to NSLayoutPriorityRequired. */ open var priority: UILayoutPriority /* When a view is archived, it archives some but not all constraints in its -constraints array. The value of shouldBeArchived informs UIView if a particular constraint should be archived by UIView. If a constraint is created at runtime in response to the state of the object, it isn't appropriate to archive the constraint - rather you archive the state that gives rise to the constraint. Since the majority of constraints that should be archived are created in Interface Builder (which is smart enough to set this prop to YES), the default value for this property is NO. */ open var shouldBeArchived: Bool /* accessors firstItem.firstAttribute &#123;==,&lt;=,&gt;=&#125; secondItem.secondAttribute * multiplier + constant Access to these properties is not recommended. Use the `firstAnchor` and `secondAnchor` properties instead. */ unowned(unsafe) open var firstItem: AnyObject &#123; get &#125; open var firstAttribute: NSLayoutAttribute &#123; get &#125; unowned(unsafe) open var secondItem: AnyObject? &#123; get &#125; open var secondAttribute: NSLayoutAttribute &#123; get &#125; /* accessors firstAnchor&#123;==,&lt;=,&gt;=&#125; secondAnchor * multiplier + constant */ @available(iOS 10.0, *) @NSCopying open var firstAnchor: NSLayoutAnchor&lt;AnyObject&gt; &#123; get &#125; @available(iOS 10.0, *) @NSCopying open var secondAnchor: NSLayoutAnchor&lt;AnyObject&gt;? &#123; get &#125; open var relation: NSLayoutRelation &#123; get &#125; open var multiplier: CGFloat &#123; get &#125; /* Unlike the other properties, the constant may be modified after constraint creation. Setting the constant on an existing constraint performs much better than removing the constraint and adding a new one that's just like the old but for having a new constant. */ open var constant: CGFloat /* The receiver may be activated or deactivated by manipulating this property. Only active constraints affect the calculated layout. Attempting to activate a constraint whose items have no common ancestor will cause an exception to be thrown. Defaults to NO for newly created constraints. */ @available(iOS 8.0, *) open var isActive: Bool /* Convenience method that activates each constraint in the contained array, in the same manner as setting active=YES. This is often more efficient than activating each constraint individually. */ @available(iOS 8.0, *) open class func activate(_ constraints: [NSLayoutConstraint]) /* Convenience method that deactivates each constraint in the contained array, in the same manner as setting active=NO. This is often more efficient than deactivating each constraint individually. */ @available(iOS 8.0, *) open class func deactivate(_ constraints: [NSLayoutConstraint])&#125;extension NSLayoutConstraint &#123; /* For ease in debugging, name a constraint by setting its identifier, which will be printed in the constraint's description. Identifiers starting with UI and NS are reserved by the system. */ @available(iOS 7.0, *) open var identifier: String?&#125; 方法说明123 public convenience init(item view1: Any, attribute attr1: NSLayoutAttribute, relatedBy relation: NSLayoutRelation, toItem view2: Any?, attribute attr2: NSLayoutAttribute, multiplier: CGFloat, constant c: CGFloat)创建一个约束 属性说明123456789101112131415//第一个view unowned(unsafe) open var firstItem: AnyObject &#123; get &#125; open var firstAttribute: NSLayoutAttribute &#123; get &#125;//第二个view unowned(unsafe) open var secondItem: AnyObject? &#123; get &#125; open var secondAttribute: NSLayoutAttribute &#123; get &#125; open var relation: NSLayoutRelation &#123; get &#125; open var multiplier: CGFloat &#123; get &#125; open var constant: CGFloat/*与其他属性不同，常数可以在约束创建后修改。 在现有约束上设置常量比删除约束并添加一个新的约束更好，这与旧的约束相同，但是具有一个新的常量。*/ 创建约束123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import UIKitclass ViewController: UIViewController &#123; var thirdView: UIView? var fourView: UIView? @IBOutlet weak var fifth: UIView!// @IBOutlet weak var secondeView: UIView!// @IBOutlet weak var firstView: UIView! override func viewDidLoad() &#123; super.viewDidLoad()// self.firstView.backgroundColor = UIColor.red self.thirdView = UIView() self.fourView = UIView() self.thirdView?.backgroundColor = UIColor.gray self.fourView?.backgroundColor = UIColor.brown self.fifth.backgroundColor = UIColor.green self.fifth.translatesAutoresizingMaskIntoConstraints = false self.view.addSubview(self.thirdView!) self.thirdView?.addSubview(self.fourView!) //使用自动布局时必须设置为false self.fourView?.translatesAutoresizingMaskIntoConstraints = false self.thirdView?.translatesAutoresizingMaskIntoConstraints = false let thirdViewWidthContraint = NSLayoutConstraint(item: self.thirdView!, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: NSLayoutAttribute.width, multiplier: 0.5, constant: 0.0) let thirdViewHeightContraint = NSLayoutConstraint(item: self.thirdView!, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: NSLayoutAttribute.height, multiplier: 0.5, constant: 0.0) let thirdViewCXContraint = NSLayoutConstraint(item: self.thirdView!, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: NSLayoutAttribute.centerX, multiplier: 1.0, constant: 0.0) let thirdViewYContraint = NSLayoutConstraint(item: self.thirdView!, attribute: NSLayoutAttribute.centerY, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: NSLayoutAttribute.centerY, multiplier: 1.0, constant: 0.0) self.view.addConstraints([thirdViewWidthContraint, thirdViewCXContraint, thirdViewHeightContraint, thirdViewYContraint]) /** *给fourView添加自动布局属性 * */ let widthContraint = NSLayoutConstraint(item: self.fourView!, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: self.thirdView!, attribute: NSLayoutAttribute.width, multiplier: 0.5, constant: 0.0) let heightContraint = NSLayoutConstraint(item: self.fourView!, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: self.thirdView!, attribute: NSLayoutAttribute.height, multiplier: 0.5, constant: 0.0) let firstCenterXContraint = NSLayoutConstraint(item: self.fourView!, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self.thirdView!, attribute: NSLayoutAttribute.centerX, multiplier: 1.0, constant: 0.0) let firstTopContraint = NSLayoutConstraint(item: self.fourView!, attribute: NSLayoutAttribute.centerY, relatedBy: NSLayoutRelation.equal, toItem: self.thirdView!, attribute: NSLayoutAttribute.centerY, multiplier: 1.0, constant: 0.0) //NSLayoutConstraint.activate([widthContraint, heightContraint, firstCenterXContraint, firstTopContraint]) self.thirdView?.addConstraint(firstTopContraint) self.thirdView?.addConstraint(firstCenterXContraint) self.thirdView?.addConstraint(widthContraint) self.thirdView?.addConstraint(heightContraint) /** *IBOutlet fifth添加自动布局属性 *使用了自动布局属性后就不能再使用frame改变视图大小了， */ fifth.frame.size.width = 100 fifth.frame.size.height = 100 let fifthWidthContraint = NSLayoutConstraint(item: self.fifth, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.width, multiplier: 1.0, constant: 100.0) let fifthHeightContraint = NSLayoutConstraint(item: self.fifth, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.height, multiplier: 1.0, constant: 100.0) let fifthTopContraint = NSLayoutConstraint(item: self.fifth, attribute: NSLayoutAttribute.top, relatedBy: NSLayoutRelation.equal, toItem: self.thirdView!, attribute: NSLayoutAttribute.bottom, multiplier: 1.0, constant: 50.0) let fifthXContraint = NSLayoutConstraint(item: self.fifth, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self.thirdView, attribute: NSLayoutAttribute.centerX, multiplier: 1.0, constant: 0.0) /** *添加宽高属性直接如果约束建立在父视图和子视图上，则添加到父视图上；如果约束建立在两个兄弟视图上，则添加到两个兄弟视图的父视图上。 */ self.view.addConstraints([fifthTopContraint, fifthXContraint]) self.fifth?.addConstraints([fifthWidthContraint, fifthHeightContraint]) // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 效果如下图","tags":[{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"NSLayoutConstraint","slug":"NSLayoutConstraint","permalink":"http://estding.com/tags/NSLayoutConstraint/"},{"name":"自动布局","slug":"自动布局","permalink":"http://estding.com/tags/自动布局/"}]},{"title":"iOS广播NotificationCenter-Swift3","date":"2016-10-16T08:50:22.000Z","path":"2016/10/16/iOS广播NotificationCenter-Swift3/","text":"NSNotificationCenter对象（或简称为通知中心）提供用于在程序内广播信息的机制。 NSNotificationCenter对象实质上是一个通知转发表。 Objects register with a notification center to receive notifications (NSNotification objects) using the addObserver(_:selector:name:object:) or addObserver(forName:object:queue:using:) methods. Each invocation of this method specifies a set of notifications. Therefore, objects may register as observers of different notification sets by calling these methods several times.Each running Cocoa program has a default notification center. You typically don’t create your own. An NSNotificationCenter object can deliver notifications only within a single program. If you want to post a notification to other processes or receive notifications from other processes, use an instance of DistributedNotificationCenter. **类实例使用addObserver（_：selector：name：object :)或addObserver（forName：object：queue：using :)在通知中心注册，接收通知（NSNotification对象）。 每次调用此方法都会指定一组通知。 因此，对象可以通过多次调用这些方法来注册为不同通知集的观察者。 每个运行的Cocoa程序都有一个默认的通知中心。 您通常不需要自己创建。 NSNotificationCenter对象只能在单个程序中传递通知。 如果要将通知发布到其他进程或从其他进程接收通知，请使用DistributedNotificationCenter的实例。** 代码123456789101112131415161718192021222324open class NotificationCenter : NSObject &#123; open class var `default`: NotificationCenter &#123; get &#125;//返回一个NotificationCenter对象 open func addObserver(_ observer: Any, selector aSelector: Selector, name aName: NSNotification.Name?, object anObject: Any?) open func post(_ notification: Notification) open func post(name aName: NSNotification.Name, object anObject: Any?) open func post(name aName: NSNotification.Name, object anObject: Any?, userInfo aUserInfo: [AnyHashable : Any]? = nil) open func removeObserver(_ observer: Any) open func removeObserver(_ observer: Any, name aName: NSNotification.Name?, object anObject: Any?) @available(iOS 4.0, *) open func addObserver(forName name: NSNotification.Name?, object obj: Any?, queue: OperationQueue?, using block: @escaping (Notification) -&gt; Swift.Void) -&gt; NSObjectProtocol&#125; 实例添加键盘监听1234 //指定键盘弹起时处理的方法 NotificationCenter.default.addObserver(self, selector: #selector(self.keyBoardWillShow(nstification:)), name: NSNotification.Name.UIKeyboardWillShow, object: nil)//指定键盘收起时的处理方法NotificationCenter.default.addObserver(self, selector: #selector(self.keyBoardWillHide(nstification:)), name: NSNotification.Name.UIKeyboardDidHide, object: nil)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://estding.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"Notification","slug":"Notification","permalink":"http://estding.com/tags/Notification/"},{"name":"iOS广播","slug":"iOS广播","permalink":"http://estding.com/tags/iOS广播/"}]},{"title":"Swift代码修改Xib或storyboard中添加的自动布局约束","date":"2016-10-16T06:59:48.000Z","path":"2016/10/16/Swift代码修改Xib或storyboard中添加的自动布局约束/","text":"很多次在xib或storyboard中添加了自动布局约束想要修改约束，但是不知道怎么修改，偶然在简书看到一篇文章才知道原来约束也是可以添加为IBoutlet. 参考文章 登录框根据键盘弹起调整布局 由于logo在最上方，只要修改logo的top约束就可以了 创建logo top约束的IBoutlet 修改约束添加动画 12345678910111213//实现UITextField代理方法 func textFieldDidBeginEditing(_ textField: UITextField) &#123; /** self.logoButoon.snp.updateConstraints &#123; (make) -&gt; Void in make.top.equalTo(120) &#125; */ UIView.animate(withDuration: 1.0, delay: 0.0, options: UIViewAnimationOptions.curveEaseInOut, animations: &#123; self.logoButtonTopContraint.constant = 70.0 &#125;, completion: nil) &#125;&#125; 上面这种方法有个bug，换一种监听键盘的方法 1234567891011121314151617181920212223242526272829303132@IBOutlet weak var logoButtonTopContraint: NSLayoutConstraint! override func viewDidLoad() &#123; super.viewDidLoad() logoButoon = &#123; logoButoon.isEnabled = false logoButoon.setBackgroundImage(UIImage(named: \"logo\"), for: UIControlState.disabled) logoButoon.setTitle(\"\", for: UIControlState.disabled) userNameTextField.delegate = self return $0 &#125;(UIButton()) NotificationCenter.default.addObserver(self, selector: #selector(self.keyBoardWillShow(nstification:)), name: NSNotification.Name.UIKeyboardWillShow, object: nil) NotificationCenter.default.addObserver(self, selector: #selector(self.keyBoardWillHide(nstification:)), name: NSNotification.Name.UIKeyboardDidHide, object: nil) // Do any additional setup after loading the view, typically from a nib. &#125; func keyBoardWillShow(nstification: NSNotification) &#123; let userInfo = nstification.userInfo let keyBoardValue = (userInfo?[\"UIKeyboardFrameEndUserInfoKey\"] as AnyObject).cgRectValue let duration: TimeInterval = (userInfo?[\"UIKeyboardAnimationDurationUserInfoKey\"] as AnyObject) as! TimeInterval UIView.animate(withDuration: duration, delay: 0.0, options: UIViewAnimationOptions.curveEaseInOut, animations: &#123; self.logoButtonTopContraint.constant = 70.0 &#125;, completion: nil) &#125; func keyBoardWillHide(nstification: NSNotification) &#123; let userInfo = nstification.userInfo let duration: TimeInterval = (userInfo![UIKeyboardAnimationDurationUserInfoKey] as AnyObject) as! TimeInterval UIView.animate(withDuration: duration, delay: 0.0, options: UIViewAnimationOptions.curveEaseInOut, animations: &#123; self.logoButtonTopContraint.constant = 144.0 &#125;, completion: nil) &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://estding.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"http://estding.com/tags/AutoLayout/"}]},{"title":"Swift学习之UserDefaults","date":"2016-10-16T02:33:19.000Z","path":"2016/10/16/Swift学习之UserDefaults/","text":"概述昨天在微博看到下面一段代码，感觉写的很巧妙于是稍微研究了一下UserDefaults这个类。 官方文档里是这样介绍的 The NSUserDefaults class provides a programmatic interface for interacting with the defaults system. The defaults system allows an application to customize its behavior to match a user’s preferences. For example, you can allow users to determine what units of measurement your application displays or how often documents are automatically saved. Applications record such preferences by assigning values to a set of parameters in a user’s defaults database. The parameters are referred to as defaults since they’re commonly used to determine an application’s default state at startup or the way it acts by default. NSUserDefaults 类为与默认系统交互提供了一个编程接口。默认值系统允许应用程序自定义其行为以匹配用户的首选项。例如，您可以允许用户以确定显示那些组件或多久文件会自动保存。应用程序通过将值分配给一组用户的默认数据库参数记录这些用户偏好设置。因为他们常用来确定应用程序在启动时的默认状态或它的默认行为。 At runtime, you use an NSUserDefaults object to read the defaults that your application uses from a user’s defaults database. NSUserDefaults caches the information to avoid having to open the user’s defaults database each time you need a default value. The synchronize() method, which is automatically invoked at periodic intervals, keeps the in-memory cache in sync with a user’s defaults database. 在运行时，您使用NSUserDefaults对象从用户的默认数据库读取应用程序使用的默认值。 NSUserDefaults缓存信息，以避免在每次需要默认值时都必须打开用户的默认数据库。 以周期性间隔自动调用的synchronize（）方法使内存中缓存与用户的默认数据库保持同步。 The NSUserDefaults class provides convenience methods for accessing common types such as floats, doubles, integers, Booleans, and URLs. A default object must be a property list, that is, an instance of (or for collections a combination of instances of): NSData, NSString, NSNumber, NSDate, NSArray, or NSDictionary. If you want to store any other type of object, you should typically archive it to create an instance of NSData. For more details, see Preferences and Settings Programming Guide. NSUserDefaults类提供了方便的方法来访问常见类型，如浮点数，双精度，整数，布尔值和URL。 默认对象必须是属性列表，也就是说，一个实例（或集合的实例组合）：NSData，NSString，NSNumber，NSDate，NSArray或NSDictionary。 如果要存储任何其他类型的对象，通常应该将其存档以创建NSData的实例。 有关详细信息，请参阅首选项和设置编程指南。 常用方法类方法 class func resetStandardUserDefaults() 同步所有更改，并在内存中释放UserDefaults +resetStandardUserDefaults releases the standardUserDefaults and sets it to nil. A new standardUserDefaults will be created the next time it’s accessed. The only visible effect this has is that all KVO observers of the previous standardUserDefaults will no longer be observing it. resetStandardUserDefaults释放standardUserDefaults并将其设置为nil。 新的standardUserDefaults将在下次访问时创建。 唯一可见的效果是，所有以前的standardUserDefaults的KVO观察者将不再观察它。 初始化方法 init() init?(suiteName: String?) get方法 func array(forKey: String)Returns the array associated with the specified key. func bool(forKey: String)Returns the Boolean value associated with the specified key. func data(forKey: String)Returns the data object associated with the specified key. func dictionary(forKey: String)Returns the dictionary object associated with the specified key. func float(forKey: String)Returns the floating-point value associated with the specified key. func integer(forKey: String)Returns the integer value associated with the specified key.. func object(forKey: String)Returns the object associated with the first occurrence of the specified default. func stringArray(forKey: String)Returns the array of strings associated with the specified key. func string(forKey: String)Returns the string associated with the specified key. func double(forKey: String)Returns the double value associated with the specified key. func url(forKey: String)Returns the NSURL instance associated with the specified key. Set方法 func set(Bool, forKey: String)Sets the value of the specified default key to the specified Boolean value. func set(Float, forKey: String)Sets the value of the specified default key to the specified floating-point value. func set(Int, forKey: String)Sets the value of the specified default key to the specified integer value. func set(Any?, forKey: String)Sets the value of the specified default key in the standard application domain. func set(Double, forKey: String)Sets the value of the specified default key to the double value. func set(URL?, forKey: String)Sets the value of the specified default key to the specified URL. remove方法 func removeObject(forKey: String)Removes the value of the specified default key in the standard application domain.","tags":[{"name":"iOS","slug":"iOS","permalink":"http://estding.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"UserDefaults","slug":"UserDefaults","permalink":"http://estding.com/tags/UserDefaults/"}]},{"title":"linux磁盘管理之df和du命令","date":"2016-10-15T09:46:32.000Z","path":"2016/10/15/linux磁盘管理之df和du命令/","text":"df du umount mount df参数说明 -h –human-readable 使用人类可读的格式(预设值是不加这个选项的…) -i, –inodes 列出 inode 资讯，不列出已使用 block -k, –kilobytes 就像是 –block-size=1024 文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks 文件-t, –type=TYPE 限制列出文件系统的 TYPE 文件-T, –print-type 显示文件系统的形式 实例 以可读的形式列出当前系统磁盘使用情况 1df -h 显示inode的信息 1df -ih du 显示指定目录或文件的大小参数说明 -a 显示当前目录下的所有文件的大小 -b 大小用bytes表示，默认为k bytes -c 最后加上所有问价的总大小 -s 只显示各档案大小的总合 (summarize) -x 或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 L 计算所有档案的大小 -h 或–human-readable 以K，M，G为单位，提高信息的可读性。 实例 显示指定文件（lock文件）的大小 1du -h lock 磁盘挂载(mount)与卸载(umount)umount 参数说明 -a 卸除/etc/mtab中记录的所有文件系统。 -h 显示帮助。 -n 卸除时不要将信息存入/etc/mtab文件中。 -r 若无法成功卸除，则尝试以只读的方式重新挂入文件系统。 -t&lt;文件系统类型&gt; 仅卸除选项中所指定的文件系统。 -v 执行时显示详细的信息。 -V 显示版本信息。 卸载挂载在指定挂载点的磁盘 1unmount -v /home 通过指定设备名卸载磁盘 1umount -v /dev/sda1 mount挂载磁盘 命令格式 1mount 参数 device(挂载的设备) dir(指定挂载的目录) 参数说明 -o ro(只读方式挂载) -o rw(读写方式挂载) -t 指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。 12mount /dev/disk2s3 /home#将设备 /dev/disk2s3挂载到 /home目录下","tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://estding.com/tags/linux命令/"},{"name":"df","slug":"df","permalink":"http://estding.com/tags/df/"},{"name":"du","slug":"du","permalink":"http://estding.com/tags/du/"}]},{"title":"linux输出重定向","date":"2016-10-06T00:50:03.000Z","path":"2016/10/06/linux/linux输出重定向/","text":"一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 输出重定向可以把命令的输出重定向到一个文件像下面这种格式 123command&gt;file//who命令输出重定向到users文件内who&gt;users 输出重定向会覆盖源文件的内容12echo line 1 &gt; userscat users //line 1 如果不希望文件被覆盖可以使用&gt;&gt;添加到文件末尾 123456echo line2 &gt; userscat users /** line1 line2*/ 输入重定向同输出定向一样也linux命令也可以从文件获取输入 123command &lt; filewc -l &lt; users#输出2 前面说到不仅有标准输入输出还有标准错误。用下面命令格式处理标准错误的重定向 12345command 2 &gt; filecommand &gt; file 2&gt;&amp;1#将 stdout 和 stderr 合并后重定向到 filecommand &lt; file1 &gt;file2#输入输出都重定向 Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下： 123command &lt;&lt; delimiter(分隔符) documentdelimiter 将两个delimiter之间的内容作为输入传递给命令 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 /dev/null如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出“的效果。","tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://estding.com/tags/linux命令/"}]},{"title":"linux命令杂记","date":"2016-10-05T15:50:25.000Z","path":"2016/10/05/linux/who和wc命令/","text":"who命令 who命令who命令是用来打印出当前系统登录的用户的信息，显示的资料包含了使用者 ID、使用的终端机、从哪边连上来的、上线时间、呆滞时间、CPU 使用量、动作等等。 wc命令Linux wc命令用于计算字数。利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 c或–bytes或–chars 只显示Bytes数。 l或–lines 只显示列数。 w或–words 只显示字数。 在默认的情况下，wc将计算指定文件的行数、字数，以及字节数。 实例统计我之前一篇日志的行数、字数、字节数、123wc vim学习笔记-基本操作.md//输出 172 375 3875 vim学习笔记-基本操作.md 利用以上两个命令我们可以统计系统当前登录的用户数 12who | wc -l输出当前登录用户数量","tags":[{"name":"liunx命令","slug":"liunx命令","permalink":"http://estding.com/tags/liunx命令/"}]},{"title":"Swift学习之闭包","date":"2016-09-25T15:26:26.000Z","path":"2016/09/25/Swift/Swift学习之闭包/","text":"闭包表达式(Closure Expressions) 尾随闭包(Trailing Closures) 值捕获(Capturing Values) 闭包是引用类型(Closures Are Reference Types) 逃逸闭包(Escaping Closures) 自动闭包(Autoclosures) 闭包是自包含的代码块，SWift闭包和objc的block相似。闭包可以捕获上下文中的常量、变量，Swift会帮你管理捕获过程中的内存。 特殊闭包 全局函数有名字不会捕获任何值得闭包。 嵌套函数，可以捕获上下文中的值。 闭包优化 利用上下文推断参数和返回类型 隐式返回单表达式闭包，即单表达式可以省略return关键字 参数名称缩写 尾随闭包语法 闭包表达式1234//定义一个闭包&#123;(parameters) -&gt; returnType in statements&#125; 根据上下文推断类型闭包作为参数传递给函数时，基本都可以推断出闭包的参数类型和返回值类型，所以可以不用完整形式构造闭包。当然如果完整格式有利于提高代码可读性，苹果官方鼓励使用完整格式的闭包。 单表达式闭包隐式返回单表达式可以省略return关键字隐式返回表达式结果。 参数名称缩写Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过$0, $1, $2 来顺序调用闭包参数。以此类推，你在表达式中使用参数名称缩写，你同样可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。in关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成 1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 运算符方法更简短的方式编写闭包，可以使用运算符方法更多关于运算符方法的内容请查看运算符方法 尾随闭包如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签： 12345678910111213func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; // 函数体部分&#125;// 以下是不使用尾随闭包进行函数调用someFunctionThatTakesAClosure(closure: &#123; // 闭包主体部分&#125;)// 以下是使用尾随闭包进行函数调用someFunctionThatTakesAClosure() &#123; // 闭包主体部分&#125; Swift自动布局框架SnapKit设置布局的方法就是用的尾随闭包 123456789let box = UIView()superview.addSubview(box)box.snp.makeConstraints &#123; (make) -&gt; Void in make.top.equalTo(superview).offset(20) make.left.equalTo(superview).offset(20) make.bottom.equalTo(superview).offset(-20) make.right.equalTo(superview).offset(-20)&#125; 值捕获闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。 闭包是引用类型对应值类型，闭包是引用类型 逃逸闭包当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。 逃逸闭包在异步操作的函数中比较常见，比如我们GET一个请求，总是等待服务器返回后调用闭包处理服务器返回的状态。 一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。 自动闭包自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。 自动闭包也可以逃逸，和前面说明的一样在闭包前加上 @escaping","tags":[{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"闭包","slug":"闭包","permalink":"http://estding.com/tags/闭包/"}]},{"title":"UILabel详解(Swift).md","date":"2016-09-24T08:47:18.000Z","path":"2016/09/24/iOS/UILabel详解/","text":"创建一个UILabel1var sLable = UILabel(frame: CGRect(x: 100, y: 200, width: 100, height: 30)) 属性 text 设置要显示的内容 lineBreakMode 设置文字显示不全是的模式 font 设置要显示文本内容 shadowColor 设置阴影颜色 numberOfLines 设置文本行数 textColer 设置文本颜色 adjustsFontSizeToFitWidth 调整字体大小适应宽度 实例1自适应高度（宽度固定） 12345678910111213141516171819//定义计算高度函数 func heightWithConstrainedWidth(string: String, width: CGFloat, font: UIFont) -&gt; CGFloat &#123; let constraintRect = CGSize(width: width, height: 100000.0) let boundingBox = string.boundingRect(with: constraintRect, options: NSStringDrawingOptions.usesLineFragmentOrigin, attributes: [NSFontAttributeName: font], context: nil) return boundingBox.height&#125; var label = UILabel()label.frame.size.width = 100 //设置宽度label.font = UIFont.systemFont(ofSize: 15.0)//设置字体大小label.numberOfLines = 0 // 0表示不限行数lable.textColor = UIColor.orange //设置颜色text = \"自适应高度（宽度固定）自适应高度（宽度固定）自适应高度（宽度固定）自适应高度（宽度固定）自适应高度（宽度固定）\"let height = heightWithConstrainedWidth(string: text, width: 100, font: UIFont.systemFont(ofSize: 16))label.frame.size.height = height//设置计算过的高度label.text = text 显示效果 设置字体通过font属性设置字体 12let font = UIFont.systemFont(ofSize: 15.0)label.font = font 设置lineBreakMode1234567891011121314151617//文字显示不全时怎么显示@available(iOS 6.0, *)public enum NSLineBreakMode : Int &#123; case byWordWrapping // Wrap at word boundaries, default case byCharWrapping // Wrap at character boundaries case byClipping // Simply clip case byTruncatingHead // Truncate at head of line: \"...wxyz\" case byTruncatingTail // Truncate at tail of line: \"abcd...\" case byTruncatingMiddle // Truncate middle of line: \"ab...yz\"&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://estding.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"},{"name":"UILabel","slug":"UILabel","permalink":"http://estding.com/tags/UILabel/"}]},{"title":"iOS自定义导航栏","date":"2016-09-17T15:09:19.000Z","path":"2016/09/17/iOS/iOS自定义导航栏/","text":"初始化UINavigationController 自定义 初始化UINavigationController在AppDelegate添加如下代码 1234567891011121314151617class AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; // Override point for customization after application launch. window = UIWindow(frame: UIScreen.main.bounds) window?.backgroundColor = UIColor.white let rootViewController = ViewController() let nav = UINavigationController(rootViewController: rootViewController) window?.makeKeyAndVisible() window?.rootViewController = nav rootViewController.view.backgroundColor = UIColor.darkGray return true &#125;&#125; viewController 123456789101112131415161718192021class ViewController: UIViewController &#123; var secoViewController : SecondeViewController? override func viewDidLoad() &#123; super.viewDidLoad() let rightButton = UIButton(frame: CGRect(x: 0, y: 0, width: 25, height: 25)) rightButton.setImage(UIImage(named: \"侧边栏\"), for: UIControlState.normal) self.navigationItem.title = \"侧边栏\" self.navigationItem.leftBarButtonItem = UIBarButtonItem(customView: rightButton) //self.navigationController?.navigationBar.backgroundColor = UIColor.red self.navigationController?.navigationBar.barTintColor = UIColor.red // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 自定义导航栏颜色1self.navigationController?.navigationBar.barTintColor = UIColor.red","tags":[{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"}]},{"title":"hexo new draft Mac Homebrew安装mysql报错ERROR 2002 (HY000) Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)解决办法","date":"2016-09-11T16:14:09.000Z","path":"2016/09/12/brew安装mysql报错/","text":"首先查看mysql有没有启动1mysql.server start","tags":[{"name":"Homebrew","slug":"Homebrew","permalink":"http://estding.com/tags/Homebrew/"},{"name":"mysql","slug":"mysql","permalink":"http://estding.com/tags/mysql/"},{"name":"Mac","slug":"Mac","permalink":"http://estding.com/tags/Mac/"}]},{"title":"mv命令","date":"2016-09-11T09:25:48.000Z","path":"2016/09/11/linux/mv命令/","text":"mv命令是move的缩写，可以用来移动文件或者将文件重命名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 命令格式 命令参数 实例 命令格式mv[选项][源文件][目的文件] 命令参数 -b ：若需覆盖文件，则覆盖前先行备份。 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会更新(update) -t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 实例 重命名文件如果文件存在提示是否覆盖 1mv -i test1 test2 移动文件不询问，文件已存在直接覆盖 移动文件到目录 重命名文件夹","tags":[{"name":"linux命令","slug":"linux命令","permalink":"http://estding.com/tags/linux命令/"}]},{"title":"Mac下ssh和scp命令","date":"2016-09-11T06:07:59.000Z","path":"2016/09/11/linux/Mac下ssh和scp命令/","text":"sshmac下要使用ssh远程登录需要在共享里勾选远程登录的选项 ssh 链接远程主机格式123ssh userName@ip//examplessh teibunchou@192.168.0.101 scp命令scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 命令格式 参数说明 实例 命令格式scp 【参数】【源路径】【目的路径】 参数说明 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 实例 将局域网内一台主机上的Vim配置文件拷贝到当前主机上 12scp username@ip:路径 目的路径scp teibunchou@192.168.0.101:/users/teibunchou/.vimrc /users/ding/ 将当前主机文件拷贝到远程主机上 1scp 源路径 username@ip:目的路径","tags":[{"name":"Linux 命令","slug":"Linux-命令","permalink":"http://estding.com/tags/Linux-命令/"}]},{"title":"Synergy配置两台Mac共享一套键盘鼠标","date":"2016-09-11T05:11:38.000Z","path":"2016/09/11/Synergy配置两台Mac共享一套键盘鼠标/","text":"准备 Synergy 1.8.2 两台运行 mac OS的电脑 设置服务端**服务端是提供共享键盘鼠标的PC** 如下图 点击设置服务端 拖动右上角显示器图标创建一个新的屏幕，这个屏幕要对应你要控制屏幕屏幕名称不能填错，双击可以设置屏幕的属性。 设置服务端有一个坑(一看就被坑过)如果是两台Mac 你会发现两台PC屏幕名称居然一样都是bogon,这里一定要改为不同的名称不然会连接失败，可以通过菜单栏&gt;编辑&gt;设置修改。 设置客户端 客户端只要输入服务端iP就行了 开始 服务端点击开始 客户端点击开始 enjoy 下载连接这个软件可用版本也不好找，我也找了好久最后把下载链接给大家附上！ Synergy 1.8.2 （提取码：6a24）","tags":[{"name":"Synergy","slug":"Synergy","permalink":"http://estding.com/tags/Synergy/"}]},{"title":"Vim学习笔记-基本操作","date":"2016-09-01T05:56:36.000Z","path":"2016/09/01/Vim/vim学习笔记-基本操作/","text":"C 代表 CTRL 插入字符 1234i 在当前光标所在字符前插入字符a 在当前光标所在字符后插入字符o 在光标下面新的一行插入字符O 在光标上面打开一个新行 移动光标 1234h 左j 下k 上l 右 删除字符 123x 删除一个字符dd 删除一整行J 删除一个换行符 撤销与重做 123u 撤销(撤销最后一步操作)C-R 重做(回退前一个命令)U 行撤销(只在最近的修改的行上做撤销操作) 指定命令执行次数 129k 向上移动9行3a!&lt;ESC&gt; 在末尾添加三个感叹号 退出 12ZZ 保存文件并退出q! 退出不保存 备注: 与其他编辑器不一样，Vim 不会自动建立一个备份文件。如果你输入 “ZZ”，你的修改立即生效并且不能恢复。你可以配置 Vim 让它产生一个备份文件.设置备份文件 词移动 1234567w 移动到下一个单词的首字母b 移动到前一个单词的首字母e 移动到下一个单词的词尾ge 移动到上一个单词的词尾$ 移动到行尾0 移动到行首^ 移动到一行的第一个非空字符 移动到指定字符 1234fx 向前查找本行的x字符F 向左查找t 移动到指定字符的前一个字符T 向左移动 括号匹配 12% 括号匹配使用(), [], &#123;&#125; 移动到指定行 12345G 移动到最后一行nG 移动到第n行gg 移动到第一行n% 移动到当前文件百分之n的位置50% 移动到文档的中间位置 确定当前位置 12345C-G得到如下信息\".vimrc\" line 23 of 45 --51%-- col 1\"文件 所在行号 文件总共行数 所在百分比 所在列 滚屏 12345678C-D 命令把视窗向下移动半屏，所以把文字向上移动半屏。C-E 每次向上滚一行C-Y 每次向下滚动一行C-F 正向滚动一整屏(减两行)C-B 反向滚动一整屏zz 调整光标位置居于屏幕中间zt 把光标所在行移动到屏幕的顶部zb 则移动到屏幕的底部 顺便贴一下目前我的Vim配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344 1 set nocompatible 2 filetype off 3 set rtp+=~/.vim/bundle/Vundle.vim 4 call vundle#begin() 5 Plugin 'VundleVim/Vundle.vim' 6 plugin 'tpope/vim-fugitve' 7 Plugin 'L9' 8 Plugin 'git://git.wincent.com/command-t.git' 9 Plugin 'rstacruz/sparkup', &#123;'rtp': 'vim/'&#125;10 Plugin 'ascenator/L9', &#123;'name': 'newL9'&#125;11 Plugin 'chrisbra/vim-airline' \"https://github.com/vim-airline/vim-airline12 Plugin 'vim-airline/vim-airline'13 Plugin 'vim-airline/vim-airline-themes'14 Plugin 'scrooloose/nerdtree'15 Plugin 'jelera/vim-javascript-syntax'16 Plugin 'vim-ruby/vim-ruby'17 Plugin 'dracula/vim'18 Plugin 'vim-scripts/ctags.vim'19 plugin 'klen/python-mode'20 Plugin 'scrooloose/syntastic'21 Plugin 'keith/swift.vim'22 Plugin 'uarun/vim-protobuf'23 Plugin 'jistr/vim-nerdtree-tabs'24 Plugin 'suan/vim-instant-markdown'25 Plugin 'plasticboy/vim-markdown'26 call vundle#end()27 filetype plugin indent on2829 let mapleader = ','30 nnoremap &lt;C-l&gt; gt31 nnoremap &lt;C-h&gt; gT32 nnoremap &lt;leader&gt;t : tabe&lt;CR&gt;3334 autocmd vimenter * NERDTree35 autocmd bufenter * if (winnr(\"$\") == 1 &amp;&amp; exists(\"b:NERDTree\") &amp;&amp; b:NERDTree.isTabTree()) | q | endif36 set fileencodings=utf-8,gb2312,gbk,gb18030,big537 set fenc=utf-838 set enc=utf-839 set number40 set laststatus=241 syntax on42 color dracula43 set ignorecase #忽略大小写44 set hlsearch #高亮所有匹配","tags":[{"name":"Vim","slug":"Vim","permalink":"http://estding.com/tags/Vim/"}]},{"title":"Swift属性和方法","date":"2016-08-30T12:52:48.000Z","path":"2016/08/30/Swift/Swift属性和方法/","text":"属性和方法 属性 存储属性 （Stored Properties） 计算属性 (Computed Properties) 属性观察器 (Property Observers) 类型属性 （Class Properties） 全局变量和局部变量 函数 函数的定义 函数的参数和返回值 函数参数名称 嵌套函数 方法 实例方法 (Instance Methods)&gt; 类方法 (Type Methods) 方法的局部参数名和外部参数名 (Local and External Parameter Names for Methods) 属性存储属性 变量存储属性和常量存储属性，可以在定义存储属性时指定默认值，也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。 1234567struct Cup &#123; var capacity:Int //变量存储属性 let material:String //常量存储属性&#125;var cup = Cup(capacity: 300, material: \"glass\")//常量属性一旦被初始化，就不能被修改了 常量结构体的存储属性因为结构体是值类型，所以如果创建一个结构体的实例把它赋值给一个常量则不能修改这个实例的任何属性，即使是变量属性。 延迟存储属性 延迟存储属性只有在第一次调用的时候才会计算其初始值得属性。在属性声明前使用lazy来标示一个延迟存储属性。 !!! 延迟属性必须声明为变量，因为延迟属性的初始值可能在实例构造完成后才会得到。而常量属性在构造完成之前必须要有初始值，因此无法声明延迟属性 12345678910111213141516171819class DataImporter &#123; /* DataImporter 是一个负责将外部文件中的数据导入的类。 这个类的初始化会消耗不少时间。 */ var fileName = \"data.txt\" // 这里会提供数据导入功能&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // 这里会提供数据管理功能&#125;let manager = DataManager()manager.data.append(\"Some data\")manager.data.append(\"Some more data\")// DataImporter 实例的 importer 属性还没有被创建 ！！！ 注意如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。 计算属性 计算属性不直接存储值，而是提供一个getter和一个setter，来间接获取和设置其他属性或变量的值。123456789101112struct \u0010Square &#123; var a: Int //边长 var area: String &#123; get &#123; return a * a &#125; set(area) &#123; sqrt(area) &#125; &#125;&#125;//area可以从边长计算出，可以定义为一个计算属性 便捷setter setter没有定义表示新值得参数名，可以使用默认名称newValue。 只读计算属性 只有getter，没有setter的计算属性就是只读属性，定义的时候可以去掉，get关键字和花括号。 !!! 注意必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值。 属性观察器属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新值和当前值相同的时候也不例外。 可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性 !!!不需要为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。(不太理解) willSet 在新的值被设置之前调用,新值会被当做参数传入，默认参数名newValue didSet 在新的值被设置之后被立即调用,就值会被当做参数传入，默认参数名oldValue 12345678910111213141516171819202122class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newTotalSteps) &#123; print(\"About to set totalSteps to \\(newTotalSteps)\") &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print(\"Added \\(totalSteps - oldValue) steps\") &#125; &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// About to set totalSteps to 200// Added 200 stepsstepCounter.totalSteps = 360// About to set totalSteps to 360// Added 160 stepsstepCounter.totalSteps = 896// About to set totalSteps to 896// Added 536 steps 类型属性也就是常说的类变量类变量是属于一个类的变量，可以通过类名直接访问，存储类型属性必须要指定默认值，这是因为类本身没有构造器，存储型类属性是延迟初始化的，而且不需要对其使用lazy修饰符。 类型属性定义语法 12345678910使用关键字 staticstruct Person &#123; static var age = 20 static var name = &quot;tom&quot; var height: Int&#125;var p = Person(height: 170)print(&quot;this is class Properties \\(Person.age), \\(Person.name)&quot;)//类属性直接用类名调用 函数定义 123function name() -&gt; 返回值类型 &#123; //函数体&#125; 多参数 123456func addString(string1: String, string2: String) -&gt; String &#123; return string1 + string2&#125;print(addString(\"say\", string2: \" hello\"))//输出say hello 无返回值的函数 就是没有任何返回值的函数，省略掉返回值声明，实际上没有定义返回类型的函数会返回特殊值，叫Void，Void是一个元组（tuple）,没有任何元素，可以写成()。 多重返回函数利用元组(tuple)类型让多个值作为一个复合值从函数中返回。 1234567func retunHeadAndTail(str: String) -&gt; (head: Character, tail: Character) &#123; return(str[str.startIndex], str[str.endIndex.predecessor()])&#125;var ht = retunHeadAndTail(\"say hello\")print(\"\\(ht.head), \\(ht.tail)\")//s,o 可选元组返回类型 123func retunHeadAndTail(str: String) -&gt; (head: Character, tail: Character)？ &#123; return(str[str.startIndex], str[str.endIndex.predecessor()])&#125; 函数的参数名称函数参数都有一个外部参数名（函数标签调用函数时使用），和一个局部参数名，外部参数名用于在函数调用时标注传递给函数的参数，局部参数名在函数的实现内部使用。 123456func addString(string1: String, name string2: String) -&gt; String &#123; return string1 + string2&#125;print(addString(\"say hello\", name: \" Tom\"))//输出say hello Tom 可以看到一般情况下，第一个参数省略其外部参数名，第二个以及随后的参数使用其局部参数名作为外部参数名。所有参数必须有独一无二的局部参数名。尽管多个参数可以有相同的外部参数名，但不同的外部参数名能让你的代码更有可读性。 指定外部参数名你可以在局部参数名前指定外部参数名，中间以空格分隔：有一个注意点就是如果你提供了外部参数名，调用函数时必须使用外部参数名。 123func name(exterParaName localParaName: Int) &#123;&#125; 如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。 忽略外部参数名如果你不想为第二个及后续的参数设置外部参数名，用一个下划线(_)代替一个明确的参数名。123func someFunction(FirstName: Int, _ secondName) &#123;&#125; 默认参数值12345func removeLastChar(str: String = \"this is a string\") &#123;&#125;removeLastChar(\"hahaha\")removeLastchar()//使用参数的默认值 ！！！将带有默认值的参数放在参数列表最后。这样可以保证在函数调用时，非默认参数的顺序是一致的，同时使得相同函数在不同情况下调用时显得更为清晰 可变参数(Variadic Parameters)语法通过在变量类型名后面加入(…)的方式定义可变参数。可变参数的传入值在函数体中变为此类型的一个数组。 1234567func add(numbers: Int...)-&gt;Int &#123; var total: Int = 0 for number in numbers &#123; total += number &#125; return total&#125; 输入输出参数变量参数，正如上面所述，仅仅能在函数体内被更改。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。定义一个输入输出参数时，在参数定义前加 inout 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。你只能传递变量给输入输出参数。你不能传入常量或者字面量（literal value），因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加&amp;符，表示这个值可以被函数修改。 ！！！注意输入输出参数不能有默认值，而且可变参数不能用 inout 标记。如果你用 inout 标记一个参数，这个参数不能被 var 或者 let 标记。1234567891011func swapTwoInts(inout a: Int, inout _ b: Int) &#123; let temporaryA = a a = b b = temporaryA&#125;ar someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")// prints \"someInt is now 107, and anotherInt is now 3\" 这个符号（&amp;）的用法有点像c++中的引用符号 函数类型(Function Types)每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成。 123456789func addTwoInts(a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125;//函数类型为(Int, Int) -&gt; Intfunc printHelloWorld() &#123; print(\"hello, world\")&#125;//() -&gt; Void 使用函数类型和使用普通类型一样，你可以定义一个函数类型的变量并将一个此函数类型的函数赋给这个变量。123var mathFunction: (Int, Int) -&gt; Int = addTwoIntsmathFunction(2, 3) 函数类型也可以作为参数类型也就是说把一个函数，当做另一个函数的参数传进去（例子以后再补充）函数作为返回类型既然函数类型和普通类型没有什么区别，那函数当然可以作为函数的返回类型了。 嵌套函数可以把函数定义在其他函数体中，称作嵌套函数，默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。 方法实例方法在类中定义的函数就叫方法，具体定义见上 self属性(The self Property) 类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。实际上，你不必在你的代码里面经常写self。不论何时，只要在一个方法中使用一个已知的属性或者方法名称，如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。这种假定在上面的Counter中已经示范了：Counter中的三个实例方法中都使用的是count（而不是self.count）。 使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。 在实例方法中修改值类型结构体，和枚举是值类型。默认情况下，值类型的属性不能再它的实例方法中被修改。使用（mutating）关键字修饰函数可以在方法内部改变他的属性 123456789101112struct Point &#123; var x = 0.0, y = 0.0 mutating func moveByx(deltaX: Double, y deltay:Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point(x: 1.0, y:1.0)somePoint.moveByx(2.0, y:3.0)print(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")//打印输出: \"The point is now at (3.0, 4.0)\" 类型方法(Type Methods)实例方法是被实例调用，类方法是属于类本身，可以直接用类名调用。类方法用static关键字修饰。 !!!在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://estding.com/tags/Swift/"}]}]